var documenterSearchIndex = {"docs":
[{"location":"#GeoData.jl","page":"GeoData.jl","title":"GeoData.jl","text":"","category":"section"},{"location":"","page":"GeoData.jl","title":"GeoData.jl","text":"GeoData","category":"page"},{"location":"#GeoData","page":"GeoData.jl","title":"GeoData","text":"GeoData\n\n(Image: ) (Image: ) (Image: Build Status) (Image: Codecov) (Image: Aqua.jl Quality Assurance)\n\nGeoData.jl defines common types and methods for working with spatial data, such as 2 or multidimensional raster arrays, multi-array stacks, and series of stacks or arrays spread over multiple files. It provides a standardised interface that allows many source data types to be used with identical syntax.\n\nData loaded with GeoData.jl has some special properties:\n\nPlots are always oriented the right way. Even if you reverse or permute a GeoArray it will still plot the right way!\nRegions and points selected with Between and Contains select the right points or whole intervals  no matter the order of the index or it's position in the cell.\nFor Projected mode GRDarray and GDALarray You can index in any projection you want to by setting the  usercrs keyword on construction. You don't even need to know the underlying projection, the conversion is  handled automatically. This means Lat/Lon EPSG(4326) can be used accross all sources seamlessly if you need that.\nPackages building on GeoData.jl can treat AbstractGeoSeries, AbstractGeoStack, and AbstrackGeoArray as black boxes:\nThe data could hold tiff or netcdf files, Arrays in memory or CuArrays on the GPU - they will all behave in the same way.\nAbstractGeoStack can be a Netcdf or HDF5 file, or a NamedTuple of GDALarray holding .tif files, or all GeoArray in memeory, but be treated as if they are all the same thing.\nModelling packages do not have to deal with the specifics of spatial file types directly.\n\nGeoData.jl extends DimensionalData.jl so that spatial data can be indexed using named dimensions like Lat and Lon, Ti (time), which can also be used in most Base and Statistics methods like mean and reduce where dims arguments are required. Much of the behaviour is covered in the DimensionalData docs.\n\nGeoData.jl provides general types for holding spatial data: GeoArray, GeoStack,  and GeoSeries, and types specific to various backends for loading disk-based data. R .grd files can be loaded natively using GRDarray and GRDstack.  GDAL files can be loaded with GDALarray and GDALstack when  ArchGDAL.jl (v0.5 or higher) is present.  NetCDF similarly can be loaded with NCDarray and NCDstack when NCDatasets.jl is available.\n\nWhen HDF5.jl is available, files from the Soil Moisture Active Passive (SMAP) dataset can be loaded using SMAPstack or SMAPseries to load whole directories. This is both useful for users of SMAP, and a demonstration of the potential to build standardised interfaces  for custom spatial dataset formats like those used in SMAP.\n\nFiles can be written to disk in all formats using write, and can (with some caveats) be written to to different formats providing file-type conversion for spatial data.\n\nExamples\n\nWe'll load a file from disk, and do some manipulations and plotting.\n\nLoad GeoData, and NCDatasets, download file and load it to  an array. This netcdf file only has one layer, if it has more we  could use NCDstack instead.\n\njulia> using GeoData, NCDatasets\n\njulia> url = \"https://www.unidata.ucar.edu/software/netcdf/examples/tos_O1_2001-2002.nc\";\n\njulia> filename = download(url, \"tos_O1_2001-2002.nc\");\n\njulia> A = NCDarray(filename)\nNCDarray (named tos) with dimensions:\n Longitude (type Lon): Float64[1.0, 3.0, …, 357.0, 359.0] (Converted: Ordered Regular Intervals)\n Latitude (type Lat): Float64[-79.5, -78.5, …, 88.5, 89.5] (Converted: Ordered Regular Intervals)\n Time (type Ti): DateTime360Day[DateTime360Day(2001-01-16T00:00:00), DateTime360Day(2001-02-16T00:00:00), …, DateTime360Day(2002-11-16T00:00:00), DateTime360Day(2002-12-16T00:00:00)] (Sampled: Ordered Irregular Intervals)\nand data: 180×170×24 Array{Union{Missing, Float32},3}\n[:, :, 1]\n missing  missing     missing  …  271.437  271.445  271.459\n missing  missing     missing     271.438  271.445  271.459\n...\n\nNow plot every third month in the first year, just using the regular index:\n\njulia> using Plots\n\njuila> A[Ti(1:3:12)] |> plot\n\n(Image: Global ocean surface temperatures)\n\nNow plot Australia in the first month of 2001. Notice we are using lat/lon coordinates  and date/time instead of regular indexes:\n\njulia> A[Ti(Contains(DateTime360Day(2001, 01, 17))), \n         Lat(Between(0.0, -50.0)), \n         Lon(Between(100.0, 160.0))] |> plot\n\n(Image: Australia regional ocean surface temperature)\n\nNow get the mean over the timespan, then save it to disk, and plot it :\n\njulia> using Statistics\n\njulia> mean_tos = mean(A; dims=Ti)\nGeoArray (named tos) with dimensions:\n Longitude (type Lon): Float64[1.0, 3.0, …, 357.0, 359.0] (Converted: Ordered Regular Intervals)\n Latitude (type Lat): Float64[-79.5, -78.5, …, 88.5, 89.5] (Converted: Ordered Regular Intervals)\n Time (type Ti): DateTime360Day[2001-01-16T00:00:00] (Sampled: Ordered Irregular Intervals)\nand data: 180×170×1 Array{Union{Missing, Float32},3}\n[:, :, 1]\n missing  missing     missing     missing  …  271.434  271.443  271.454\n missing  missing     missing     missing     271.434  271.443  271.454\n...\n\njulia> write(\"mean.ncd\", NCDarray, mean_tos)\n    Writing netcdf...\n        key: \"longitude\" of type: Float64\n        key: \"latitude\" of type: Float64\n        key: \"time\" of type: DateTime360Day\n        key: \"tos\" of type: Union{Missing, Float32}\n\"mean.ncd\"\n\njulia> plot(mean_tos; color=:viridis) \n\n(Image: Mean temperatures)\n\nPlotting recipes in DimensionalData.jl are the fallback for GedData.jl when  the object doesn't have both Lat and Lon dimensions. So (as a random example) we  could plot a transect of ocean surface temperature at 20 degree latitude :\n\nA[Lat(Contains(20.0)), Ti(1)] |> plot\n\n(Image: Temperatures at lattitude 20-21)\n\nGeoData.jl provides a range of other methods that are being added to over time. One example is aggregate, that can aggregate GeoArray by axis-specific amounts:\n\njulia> aggregate(mean, A, (Ti(12), Lat(20), Lon(20))\n\nGeoArray (named tos) with dimensions:\n Longitude (type Lon): Float64[21.0, 61.0, …, 301.0, 341.0] (Converted: Ordered Regular Intervals)\n Latitude (type Lat): Float64[-69.5, -49.5, …, 50.5, 70.5] (Converted: Ordered Regular Intervals)\n Time (type Ti): DateTime360Day[2001-01-16T00:00:00, 2002-01-16T00:00:00] (Sampled: Ordered Irregular Intervals)\nand data: 9×8×2 Array{Union{Missing, Float32},3}\n[:, :, 1]\n missing  277.139        missing     missing     missing     missing  missing  missing\n missing  277.126        missing     missing     missing     missing  missing  missing\n\nThis will also work for entire GeoStacks and GeoSeries using the same syntax.\n\nWorks in progress\n\nIntegration with Vector/DataFrame spatial types and point/line/polygon data types. It should be possible to select polygons of data, and convert between linear datasets and array formats.\nStandardised handling and conversion of spatial metadata between data formats\nHandling complex projections: Affine transformation of dimensions to indices. AffineMaps will be stored as a wrapper dimension in dims.\nLoad and write the NetCDF projection format.\n\n\n\n\n\n","category":"module"},{"location":"#Dimensions","page":"GeoData.jl","title":"Dimensions","text":"","category":"section"},{"location":"","page":"GeoData.jl","title":"GeoData.jl","text":"Lat\nLon\nVert\nBand\nProjected\nConverted","category":"page"},{"location":"#GeoData.Lat","page":"GeoData.jl","title":"GeoData.Lat","text":"Lat <: YDim <: Dimension\nLat(val=:)\n\nLatitude Dimension.\n\nExample:\n\nvertdim = Lat(10:10:100)\n# Or\nval = A[Lat(1)]\n# Or\nmean(A; dims=Lat)\n\n\n\n\n\n","category":"type"},{"location":"#GeoData.Lon","page":"GeoData.jl","title":"GeoData.Lon","text":"Lon <: XDim <: Dimension\nLon(val=:)\n\nLongitude Dimension.\n\nExample:\n\nlongdim = Lon(10:10:100)\n# Or\nval = A[Lon(1)]\n# Or\nmean(A; dims=Lon)\n\n\n\n\n\n","category":"type"},{"location":"#GeoData.Vert","page":"GeoData.jl","title":"GeoData.Vert","text":"Vert <: ZDim <: Dimension\nVert(val=:)\n\nVertical Dimension.\n\nExample:\n\nvertdim = Vert(10:10:100)\n# Or\nval = A[Vert(1)]\n# Or\nmean(A; dims=Vert)\n\n\n\n\n\n","category":"type"},{"location":"#GeoData.Band","page":"GeoData.jl","title":"GeoData.Band","text":"Band <: Dimension\nBand(val=:)\n\nBand Dimension for multi-band rasters.\n\nExample:\n\nbanddim = Band(10:10:100)\n# Or\nval = A[Band(1)]\n# Or\nmean(A; dims=Band)\n\n\n\n\n\n","category":"type"},{"location":"#GeoData.Projected","page":"GeoData.jl","title":"GeoData.Projected","text":"Projected(order::Order, span, sampling, crs, usercrs)\nProjected(; order=Ordered(), span=UnknownSpan(), sampling=Points(), crs, usercrs=nothing)\n\nAn AbstractSampled IndexMode with projections attached.\n\nFields and behaviours are identical to Sampled with the addition of crs and usercrs fields.\n\nIf both crs and usercrs fields contain CRS data (in a GeoFormat wrapper from GeoFormatTypes.jl) the selector inputs and plot axes will be converted from and to the specified usercrs projection automatically. A common use case would be to pass usercrs=EPSG(4326) to the constructor when loading eg. a GDALarray:\n\nGDALarray(filename; usercrs=EPSG(4326))\n\nThe underlying crs will be detected by GDAL.\n\nIf usercrs is not supplied (ie. usercrs=nothing), the base index will be shown on plots, and selectors will need to use whatever format it is in.\n\n\n\n\n\n","category":"type"},{"location":"#GeoData.Converted","page":"GeoData.jl","title":"GeoData.Converted","text":"Converted(order::Order, span, sampling, crs, dimcrs)\nConverted(; order=Ordered(), span=UnknownSpan(), sampling=Points(), crs, dimcrs)\n\nAn AbstractSampled IndexMode with projections, where the dimension index has already been converted to another projection as a vector, usually EPSG(4326).\n\nFields and behaviours are identical to Sampled with the addition of crs and dimcrs fields.\n\nThe dimension will be indexed as for Sampled, but to save in another format the underlying projection will be used.\n\nGDALarray(filename; usercrs=EPSG(4326))\n\nThe underlying crs will be detected by GDAL.\n\nIf usercrs is not supplied (ie. usercrs=nothing), the base index will be shown on plots, and selectors will need to use whatever format it is in.\n\n\n\n\n\n","category":"type"},{"location":"#Array","page":"GeoData.jl","title":"Array","text":"","category":"section"},{"location":"","page":"GeoData.jl","title":"GeoData.jl","text":"AbstractGeoArray\nMemGeoArray\nDiskGeoArray\nGeoArray","category":"page"},{"location":"#GeoData.AbstractGeoArray","page":"GeoData.jl","title":"GeoData.AbstractGeoArray","text":"AbstractGeoArray wraps an array (or location of an array) and metadata about its contents. It may be memory (GeoArray) or disk-backed (NCDarray, GDALarray, GRDarray).\n\nAbstractGeoArrays inherit from AbstractDimArray  from DimensionalData.jl. They can be indexed as regular Julia arrays or with  DimensionalData.jl Dimensions. They will plot as a heatmap in  Plots.jl with correct coordinates and labels, even after slicing with  getindex or view. getindex on a AbstractGeoArray will always return  a memory-backed GeoArray.\n\n\n\n\n\n","category":"type"},{"location":"#GeoData.MemGeoArray","page":"GeoData.jl","title":"GeoData.MemGeoArray","text":"Abstract supertype for all memory-backed GeoArrays where the data is an array.\n\n\n\n\n\n","category":"type"},{"location":"#GeoData.DiskGeoArray","page":"GeoData.jl","title":"GeoData.DiskGeoArray","text":"Abstract supertype for all disk-backed GeoArrays. For these the data is lazyily loaded from disk.\n\n\n\n\n\n","category":"type"},{"location":"#GeoData.GeoArray","page":"GeoData.jl","title":"GeoData.GeoArray","text":"GeoArray(A::AbstractArray{T,N}, dims::Tuple;\n         refdims=(), name=\"\", metadata=nothing, missingval=missing)\nGeoArray(A::AbstractArray{T,N}; \n         dims, refdims=(), name=\"\", metadata=nothing, missingval=missing)\nGeoArray(A::AbstractGeoArray; [data=data(A), dims=dims(A), refdims=refdims(A),\n         name=name(A), metadata=metadata(A), missingval=missingval(A)]) =\n\nA generic, memory-backed spatial array type. All AbstractGeoArray are converted to GeoArray when indexed or otherwise transformed.\n\nKeyword Arguments\n\nname: String name for the array.\ndims: Tuple of Dimensions for the array.\nrefdims: Tuple of position Dimensions the array was sliced from,  defaulting to ().\nmissingval: Value reprsenting missing values, defaulting to missing. can be passed it.\nmetadata: Metadata object for the array, or nothing. \n\nExample\n\nA = GRDarray(gdalarray; name=\"surfacetemp\")\n# Select Australia using lat/lon coords, whatever the crs is underneath.\nA[Lat(Between(-10, -43), Lon(Between(113, 153)))\n\n\n\n\n\n","category":"type"},{"location":"#Stack","page":"GeoData.jl","title":"Stack","text":"","category":"section"},{"location":"","page":"GeoData.jl","title":"GeoData.jl","text":"AbstractGeoStack\nMemGeoStack\nGeoStack\nDiskGeoStack\nDiskStack\nSMAPstack","category":"page"},{"location":"#GeoData.AbstractGeoStack","page":"GeoData.jl","title":"GeoData.AbstractGeoStack","text":"AbstractGeoStack objects hold multipl AbstractGeoArray  that share spatial bounds.\n\nThey are NamedTuple-like structures that may either contain NamedTuple of AbstractGeoArray, string paths that will load AbstractGeoArray,  or a single path that points to as a file itself containing multiple layers, like  NetCDF or HDF5. Use and syntax is similar or identical for all cases.\n\ngetindex on a AbstractGeoStack generally returns a memory backed standard  GeoArray. geoarray[:somelayer] |> plot plots the layers array, while geoarray[:somelayer, Lon(1:100), Band(2)] |> plot will plot the subset without loading the whole array.\n\ngetindex on a AbstractGeoStack with a key returns another stack with  getindex applied to all the arrays in the stack.\n\n\n\n\n\n","category":"type"},{"location":"#GeoData.MemGeoStack","page":"GeoData.jl","title":"GeoData.MemGeoStack","text":"An AbstractGeoStack stored in memory.\n\n\n\n\n\n","category":"type"},{"location":"#GeoData.GeoStack","page":"GeoData.jl","title":"GeoData.GeoStack","text":"GeoStack(data...; keys, kwargs...)\nGeoStack(data::Union{Vector,Tuple}; keys, kwargs...)\nGeoStack(data::NamedTuple; window=(), metadata=nothing, refdims=(), childkwargs=()) =\nGeoStack(s::AbstractGeoStack; [keys, data, refdims, window, metadata])\n\nA concrete MemGeoStack implementation. Holds layers of GeoArray.\n\nArgumenst\n\ndata: A NamedTuple of GeoArray, or a Vector, Tuple or splatted arguments of GeoArray. The latter options must pass a keys keyword argument.\n\nKeyword Argumenst\n\nkeys: Used as stack keys when a Tuple or Vector or splat of geoarrays are passed in.\nwindow: A Tuple of Dimension/Selector/indices that will be applied to the  contained arrays when they are accessed.\nrefdims: Reference dimensions from earlier subsetting.\nmetadata: Metadata as a StackMetadata object.\nchildkwargs: A NamedTuple of keyword arguments to pass to the constructor.\nrefdims: Tuple of  position Dimension the array was sliced from.\n\n\n\n\n\n","category":"type"},{"location":"#GeoData.DiskGeoStack","page":"GeoData.jl","title":"GeoData.DiskGeoStack","text":"AbstractGeoStacks stored on disk.\n\n\n\n\n\n","category":"type"},{"location":"#GeoData.DiskStack","page":"GeoData.jl","title":"GeoData.DiskStack","text":"DiskStack(filenames...; keys, kwargs...)\nDiskStack(filenames; keys, kwargs...)\nDiskStack(filenames::NamedTuple; \n          window=(), \n          metadata=nothing, \n          childtype, \n          childkwargs=()\n          refdims=())\n\nConcrete DiskGeoStack implementation. Loads a stack of files lazily from disk.\n\nArguments\n\nfilename: a NamedTuple of stack keys and String filenames.\n\nKeyword arguments\n\nkeys: Used as stack keys when a Tuple, Vector or splat of filenames are passed in.\nwindow: A Tuple of Dimension/Selector/indices that will be applied to the  contained arrays when they are accessed.\nmetadata: Metadata as a StackMetadata object.\nchildtype: The type of the child data. eg. GDALarray. Required.\nchildkwargs: A NamedTuple of keyword arguments to pass to the childtype constructor.\nrefdims: Tuple of  position Dimension the array was sliced from.\n\n\n\n\n\n","category":"type"},{"location":"#GeoData.SMAPstack","page":"GeoData.jl","title":"GeoData.SMAPstack","text":"SMAPstack(filename::String; \n          dims=nothing,\n          refdims=nothing,\n          window=())\n\nAbstractGeoStack for SMAP datasets.\n\nThe simplicity of the format means dims and metadata are the same for all stack layers, so we store them as stack fields.\n\nArguments\n\nfilename: String path to a SMAP .h5 file.\n\nKeyword arguments\n\ndims: Dimensions held on the stack as all layers have identical Dimensions.  These are loaded from the HDF5 by default, but can be passed in to improve performance, as is done by SMAPseries, \nrefdims: As for dims. Often the position time Dimension from the SMAPseries.\nmetadata: SMAPstackMetadata object. As for dims.\nwindow: Like view but lazy, for disk based data. Can be a tuple of Dimensions, selectors or regular indices. These will be applied when the data is loaded or indexed into.\n\n\n\n\n\n","category":"type"},{"location":"#Series","page":"GeoData.jl","title":"Series","text":"","category":"section"},{"location":"","page":"GeoData.jl","title":"GeoData.jl","text":"AbstractGeoSeries\nGeoSeries\nSMAPseries","category":"page"},{"location":"#GeoData.AbstractGeoSeries","page":"GeoData.jl","title":"GeoData.AbstractGeoSeries","text":"AbstractGeoSeries are a high-level DimensionalArray that hold stacks, arrays,  or the paths they can be loaded from. GeoSeries are indexed with dimensions as with a AbstractGeoArray. This is useful when you have multiple files containing rasters or stacks of rasters spread over dimensions like time and elevation. As much as possible, implementations should facilitate loading entire directories and detecting the dimensions from metadata.\n\nThis allows syntax like:\n\nseries[Time(Near(DateTime(2001, 1))][:temp][Lat(Between(70, 150)), Lon(Between(-20,20))] |> plot`\n\nGeoSeries is the only concrete implementation. It includes a chiltype field  indicating the constructor used then loading stacks or arrays of any type from disk, and holds a kwargs NamedTuple that will be splatted into to the keyword arguments of the childtype constructor. This gives control over the construction of lazy-loaded  files.\n\n\n\n\n\n","category":"type"},{"location":"#GeoData.GeoSeries","page":"GeoData.jl","title":"GeoData.GeoSeries","text":"GeoSeries(data::Array{T}, dims; refdims=(), childtype=DD.basetypeof(T), \n          childkwargs=()) where T<:Union{<:AbstractGeoStack,<:AbstractGeoArray}\nGeoSeries(data, dims; refdims=(), childtype, childkwargs)\n\nConcrete implementation of AbstractGeoSeries. Series hold paths to array or stack files, along some dimension(s).\n\n\n\n\n\n","category":"type"},{"location":"#GeoData.SMAPseries","page":"GeoData.jl","title":"GeoData.SMAPseries","text":"SMAPseries(filenames::AbstractString; kwargs...)\nSMAPseries(filenames::Vector{<:AbstractString}, dims=nothing; kwargs...)\n\nGeoSeries loader for SMAP files and whole folders of files,  organised along the time dimension. Returns a GeoSeries.\n\nArguments\n\nfilenames: A String path to a directory of SMAP files, or a vector of String paths to specific files.\ndims: Tuple containing Ti dimension for the series.  Automatically generated form filenames unless passed in.\n\nKeyword Arguments\n\nkwargs: Passed to GeoSeries.\n\n\n\n\n\n","category":"function"},{"location":"#Metadata","page":"GeoData.jl","title":"Metadata","text":"","category":"section"},{"location":"","page":"GeoData.jl","title":"GeoData.jl","text":"Metadata\nDimMetadata\nArrayMetadata\nStackMetadata","category":"page"},{"location":"#GeoData.Metadata","page":"GeoData.jl","title":"GeoData.Metadata","text":"Supertype for all metadata wrappers.\n\nThese allow tracking the contents and origin of metadata.  This can facilitate conversion between metadata types (for saving  a file to a differenet format) or simply saving data back to the  same file type with identical metadata.\n\n\n\n\n\n","category":"type"},{"location":"#GeoData.DimMetadata","page":"GeoData.jl","title":"GeoData.DimMetadata","text":"Metadata wrappers to be attached to Dimensions.\n\n\n\n\n\n","category":"type"},{"location":"#GeoData.ArrayMetadata","page":"GeoData.jl","title":"GeoData.ArrayMetadata","text":"Metadata wrappers to be attached to AbstractGeoArrays.\n\n\n\n\n\n","category":"type"},{"location":"#GeoData.StackMetadata","page":"GeoData.jl","title":"GeoData.StackMetadata","text":"Metadata wrappers to be attached to AbstractGeoStack.\n\n\n\n\n\n","category":"type"},{"location":"#Sources","page":"GeoData.jl","title":"Sources","text":"","category":"section"},{"location":"#GRD","page":"GeoData.jl","title":"GRD","text":"","category":"section"},{"location":"","page":"GeoData.jl","title":"GeoData.jl","text":"R GRD files can be loaded natively. The are always 3 dimensional, and have Lat, Lon and Band dimensions.","category":"page"},{"location":"","page":"GeoData.jl","title":"GeoData.jl","text":"If ArchGDAL.jl is loaded, they can have usercrs and be ","category":"page"},{"location":"","page":"GeoData.jl","title":"GeoData.jl","text":"GRDarray\nGRDstack\nGRDdimMetadata\nGRDarrayMetadata","category":"page"},{"location":"#GeoData.GRDarray","page":"GeoData.jl","title":"GeoData.GRDarray","text":"GRDarray(filename::String; \n    usercrs=nothing,\n    dims=(), \n    refdims=(), \n    name=nothing, \n    missingval=nothing, \n    metadata=nothing)\n\nA DiskGeoArray that loads .grd files lazily from disk.\n\nGRDarrays are always 3 dimensional, and have Lat, Lon and Band dimensions.\n\nArguments\n\nfilename: String pointing to a grd file. Extension is optional.\n\nKeyword Arguments\n\nusercrs: CRS format like EPSG(4326) used in Selectors like Between and At, and  for plotting. Can be any CRS GeoFormat from GeoFormatTypes.jl, like WellKnownText.\nname: String name for the array, taken from the files layername attribute unless passed in.\ndims: Tuple of Dimensions for the array. Detected automatically, but can be passed in.\nrefdims: Tuple of position Dimensions the array was sliced from.\nmissingval: Value reprsenting missing values. Detected automatically when possible, but  can be passed it.\nmetadata: Metadata object for the array. Detected automatically as GRDarrayMetadata, but can be passed in.\n\nExample\n\nA = GRDarray(\"folder/file.grd\"; usercrs=EPSG(4326))\n# Select Australia using lat/lon coords, whatever the crs is underneath.\nA[Lat(Between(-10, -43), Lon(Between(113, 153)))\n\n\n\n\n\n","category":"type"},{"location":"#GeoData.GRDstack","page":"GeoData.jl","title":"GeoData.GRDstack","text":"GRDstack(filenames; keys, kwargs...)\nGRDstack(filenames...; keys, kwargs...)\nGRDstack(filenames::NamedTuple;\n         window=(), \n         metadata=nothing, \n         childkwargs=(),\n         refdims=())\n\nConvenience method to create a DiskStack of GRDarray from filenames.\n\nArguments\n\nfilenames: A NamedTuple of stack keys and String filenames, or a Tuple,  Vector or splatted arguments of String filenames.\n\nKeyword arguments\n\nkeys: Used as stack keys when a Tuple, Vector or splat of filenames are passed in.\nwindow: A Tuple of Dimension/Selector/indices that will be applied to the  contained arrays when they are accessed.\nmetadata: Metadata as a StackMetadata object.\nchildkwargs: A NamedTuple of keyword arguments to pass to the childtype constructor.\nrefdims: Tuple of  position Dimension the array was sliced from.\n\nExample\n\nCreate a GRDstack from four files, that sets the child arrays  usercrs value when they are loaded.\n\nfiles = (:temp=\"temp.tif\", :pressure=\"pressure.tif\", :relhum=\"relhum.tif\")\nstack = GRDstack(files; childkwargs=(usercrs=EPSG(4326),))\nstack[:relhum][Lat(Contains(-37), Lon(Contains(144))\n\n\n\n\n\n","category":"function"},{"location":"#GeoData.GRDdimMetadata","page":"GeoData.jl","title":"GeoData.GRDdimMetadata","text":"Metadata wrapper for GRDarray dimension metadata.\n\n\n\n\n\n","category":"type"},{"location":"#GeoData.GRDarrayMetadata","page":"GeoData.jl","title":"GeoData.GRDarrayMetadata","text":"Metadata wrapper for GRDarray metadata.\n\n\n\n\n\n","category":"type"},{"location":"#NetCDF","page":"GeoData.jl","title":"NetCDF","text":"","category":"section"},{"location":"","page":"GeoData.jl","title":"GeoData.jl","text":"NetCDF files required NCDatasets.jl:","category":"page"},{"location":"","page":"GeoData.jl","title":"GeoData.jl","text":"using NCDatasets","category":"page"},{"location":"","page":"GeoData.jl","title":"GeoData.jl","text":"Single files can be treated as a array or a stack of arrays. ","category":"page"},{"location":"","page":"GeoData.jl","title":"GeoData.jl","text":"NCDarray\nNCDstack\nNCDdimMetadata\nNCDarrayMetadata\nNCDstackMetadata","category":"page"},{"location":"#GeoData.NCDarray","page":"GeoData.jl","title":"GeoData.NCDarray","text":"NCDarray(filename::AbstractString; name=nothing, refdims=(),\n         dims=nothing, metadata=nothing, crs=EPSG(4326), dimcrs=EPSG(4326))\n\nA DiskGeoArray that loads that loads NetCDF files lazily from disk.\n\nThe first non-dimension layer of the file will be used as the array. Dims are usually detected as Lat, Lon, Ti, and [Vert] or possibly X, Y, Z when detected. Undetected dims will use the generic Dim{:name}.\n\nThis is an incomplete implementation of the NetCDF standard. It will currently handle simple files in lattitude/longitude projections, or projected formats if you manually specify crs and dimcrs. How this is done may also change in future, including detecting and converting the native NetCDF projection format.\n\nArguments\n\nfilename: String pointing to a netcdf file.\n\nKeyword arguments\n\ncrs: defaults to lat/lon EPSG(4326) but may be any GeoFormat like WellKnownText. If the underlying data is in a different projection crs will need to be set to allow write to a different file format. In future this may be detected automatically.\ndimcrs: The crs projection actually present in the Dimension index Vector, which may be different to the underlying projection. Defaults to lat/lon EPSG(4326) but may be any crs GeoFormat.\nname: String name for the array. Will use array key if not supplied.\ndims: Tuple of Dimensions for the array. Detected automatically, but can be passed in.\nrefdims: Tuple of position Dimensions the array was sliced from.\nmissingval: Value reprsenting missing values. Detected automatically when possible, but can be passed it.\nmetadata: Metadata object for the array. Detected automatically as NCDarrayMetadata, but can be passed in.\n\nExample\n\nA = NCDarray(\"folder/file.ncd\")\n# Select Australia from the default lat/lon coords:\nA[Lat(Between(-10, -43), Lon(Between(113, 153)))\n\n\n\n\n\n","category":"type"},{"location":"#GeoData.NCDstack","page":"GeoData.jl","title":"GeoData.NCDstack","text":"NCDstack(filenames; keys, kwargs...)\nNCDstack(filenames...; keys, kwargs...)\nNCDstack(files::NamedTuple; refdims=(), window=(), metadata=nothing, childkwargs=())\nNCDstack(filename::String; refdims=(), window=(), metadata=nothing, childkwargs=())\n\nA lazy AbstractGeoStack that uses NCDatasets.jl to load NetCDF files. Can load a single multi-layer netcdf file, or multiple single-layer netcdf files. In multi-file mode it returns a regular GeoStack with a childtype of NCDarray.\n\nIndexing into NCDstack with layer keys (Symbols) returns a GeoArray. Dimensions are usually detected as Lat, Lon, Ti, and [Vert] or X, Y, Z when detected. Undetected dims use the generic Dim{:name}.\n\nArguments\n\nfilename: Tuple or Vector or splatted arguments of String, or single String path, to NetCDF files.\n\nKeyword arguments\n\nkeys: Used as stack keys when a Tuple, Vector or splat of filenames are passed in. These default to the first non-dimension data key in each NetCDF file.\nrefdims: Add dimension position array was sliced from. Mostly used programatically.\nwindow: A Tuple of Dimension/Selector/indices that will be applied to the contained arrays when they are accessed.\nmetadata: A StackMetadata object.\nchildkwargs: A NamedTuple of keyword arguments to pass to the NCDarray constructor.\n\nExamples\n\nstack = NCDstack(filename; window=(Lat(Between(20, 40),))\n# Or\nstack = NCDstack([fn1, fn1, fn3, fn4])\n# And index with a layer key\nstack[:soiltemp]\n\n\n\n\n\n","category":"type"},{"location":"#GeoData.NCDdimMetadata","page":"GeoData.jl","title":"GeoData.NCDdimMetadata","text":"NCDdimMetadata(val::Dict)\n\nMetadata wrapper for NCDarray dimensions.\n\n\n\n\n\n","category":"type"},{"location":"#GeoData.NCDarrayMetadata","page":"GeoData.jl","title":"GeoData.NCDarrayMetadata","text":"NCDarrayMetadata(val::Dict)\n\nMetadata wrapper for NCDarray metadata.\n\n\n\n\n\n","category":"type"},{"location":"#GeoData.NCDstackMetadata","page":"GeoData.jl","title":"GeoData.NCDstackMetadata","text":"NCDstackMetadata(val::Dict)\n\nMetadata wrapper for NCDarray metadata.\n\n\n\n\n\n","category":"type"},{"location":"#GDAL","page":"GeoData.jl","title":"GDAL","text":"","category":"section"},{"location":"","page":"GeoData.jl","title":"GeoData.jl","text":"GDAL requires ArchGDAL.jl to be available: ","category":"page"},{"location":"","page":"GeoData.jl","title":"GeoData.jl","text":"using ArchGDAL","category":"page"},{"location":"","page":"GeoData.jl","title":"GeoData.jl","text":"GDALarray\nGDALstack\nGDALdimMetadata\nGDALarrayMetadata","category":"page"},{"location":"#GeoData.GDALarray","page":"GeoData.jl","title":"GeoData.GDALarray","text":"GDALarray(filename; \n          usercrs=nothing, \n          name=\"\", \n          dims=nothing, \n          refdims=(), \n          metadata=nothing, \n          missingval=nothing)\n\nLoad a file lazily using gdal. GDALarray will be converted to GeoArray  after indexing or other manipulations. GeoArray(GDALarray(filename)) will do this immediately.\n\nGDALarrays are always 3 dimensional, and have Lat, Lon and Band dimensions.\n\nArguments\n\nfilename: String pointing to a grd file. Extension is optional.\n\nKeyword arguments\n\nusercrs: CRS format like EPSG(4326) used in Selectors like Between and At, and  for plotting. Can be any CRS GeoFormat from GeoFormatTypes.jl, like WellKnownText.\nname: String name for the array.\ndims: Tuple of Dimensions for the array. Detected automatically, but can be passed in.\nrefdims: Tuple of position Dimensions the array was sliced from.\nmissingval: Value reprsenting missing values. Detected automatically when possible, but  can be passed it.\nmetadata: Metadata object for the array. Detected automatically as GDALarrayMetadata, but can be passed in.\n\nExample\n\nA = GDALarray(\"folder/file.tif\"; usercrs=EPSG(4326))\n# Select Australia using lat/lon coords, whatever the crs is underneath.\nA[Lat(Between(-10, -43), Lon(Between(113, 153)))\n\n\n\n\n\n","category":"type"},{"location":"#GeoData.GDALstack","page":"GeoData.jl","title":"GeoData.GDALstack","text":"GDALstack(filenames; keys, kwargs...)\nGDALstack(filenames...; keys, kwargs...)\nGDALstack(filenames::NamedTuple; \n          window=(), \n          metadata=nothing, \n          childkwargs=(),\n          refdims=())\n\nConvenience method to create a DiskStack  of GDALarray from filenames.\n\nLoad a stack of files lazily from disk.\n\nArguments\n\nfilenames: A NamedTuple of stack keys and String filenames, or a Tuple,  Vector or splatted arguments of String filenames.\n\nKeyword arguments\n\nkeys: Used as stack keys when a Tuple, Vector or splat of filenames are passed in.\nwindow: A Tuple of Dimension/Selector/indices that will be applied to the  contained arrays when they are accessed.\nmetadata: Metadata as a StackMetadata object.\nchildkwargs: A NamedTuple of keyword arguments to pass to the childtype constructor.\nrefdims: Tuple of  position Dimension the array was sliced from.\n\nExample\n\nCreate a GDALstack from four files, that sets the child arrays usercrs value when they are loaded.\n\nfiles = (:temp=\"temp.tif\", :pressure=\"pressure.tif\", :relhum=\"relhum.tif\")\nstack = GDALstack(files; childkwargs=(usercrs=EPSG(4326),))\nstack[:relhum][Lat(Contains(-37), Lon(Contains(144))\n\n\n\n\n\n","category":"function"},{"location":"#GeoData.GDALdimMetadata","page":"GeoData.jl","title":"GeoData.GDALdimMetadata","text":"GDALmetadata(val::Dict)\n\nMetadata wrapper for GDALarray dimensions.\n\n\n\n\n\n","category":"type"},{"location":"#GeoData.GDALarrayMetadata","page":"GeoData.jl","title":"GeoData.GDALarrayMetadata","text":"GDALarrayMetadata(val::Dict)\n\nMetadata wrapper for GDALarray.\n\n\n\n\n\n","category":"type"},{"location":"#SMAP","page":"GeoData.jl","title":"SMAP","text":"","category":"section"},{"location":"","page":"GeoData.jl","title":"GeoData.jl","text":"The Soil Moisture Active-Passive dataset provides global layers of soil moisture, temperature and other related data.","category":"page"},{"location":"","page":"GeoData.jl","title":"GeoData.jl","text":"It uses a custom format of HDF5 files, so required HDF5.jl to be available:","category":"page"},{"location":"","page":"GeoData.jl","title":"GeoData.jl","text":"using HDF5","category":"page"},{"location":"","page":"GeoData.jl","title":"GeoData.jl","text":"Files must be downloaded manually due to authentication restrictions. As the datasets are know files in standardised formats, whole folders can be loaded using SMAPseries. Methods like aggregate can be done over whole folders of stacks of data with a single command.","category":"page"},{"location":"","page":"GeoData.jl","title":"GeoData.jl","text":"SMAPdimMetadata\nSMAParrayMetadata\nSMAPstackMetadata","category":"page"},{"location":"#GeoData.SMAPdimMetadata","page":"GeoData.jl","title":"GeoData.SMAPdimMetadata","text":"SMAPdimMetadata(val)\n\nDimMetadata wrapper for SMAParray dimensions.\n\n\n\n\n\n","category":"type"},{"location":"#GeoData.SMAParrayMetadata","page":"GeoData.jl","title":"GeoData.SMAParrayMetadata","text":"SMAParrayMetadata(val)\n\nArrayMetadata wrapper for SMAParray.\n\n\n\n\n\n","category":"type"},{"location":"#GeoData.SMAPstackMetadata","page":"GeoData.jl","title":"GeoData.SMAPstackMetadata","text":"SMAPdimMetadata(val)\n\nStackMetadata wrapper for SMAPstack.\n\n\n\n\n\n","category":"type"},{"location":"#Helper-methods","page":"GeoData.jl","title":"Helper methods","text":"","category":"section"},{"location":"","page":"GeoData.jl","title":"GeoData.jl","text":"See DimensionalData.jl docs for the majority of types and methods that can be used in GeoData.jl.  GeoData.jl is a direct extension of DimensionalData.jl.","category":"page"},{"location":"","page":"GeoData.jl","title":"GeoData.jl","text":"These methods are specific to GeoData.jl:","category":"page"},{"location":"","page":"GeoData.jl","title":"GeoData.jl","text":"write\ncat\ncopy!\nreplace_missing\nboolmask\nmissingmask\nconvertmode\nreproject\naggregate\naggregate!\ndisaggregate\ndisaggregate!\nGeoData.alloc_ag\nGeoData.alloc_disag","category":"page"},{"location":"#Base.write","page":"GeoData.jl","title":"Base.write","text":"Base.write(filename::AbstractString, T::Type{<:AbstractGeoArray}, s::AbstractGeoStack)\n\nSave all layers of an AbstractGeoStack to separate files, using the backend determined by T.\n\nExample\n\nwrite(filename, GDALarray, A)\n\n\n\n\n\nBase.write(filename::AbstractString, ::Type{GRDarray}, s::AbstractGeoArray)\n\nWrite a GRDarray to a .grd file, with a .gri header file. The extension of filename will be ignored.\n\nCurrently the metadata field is lost on write for GRDarray.\n\nReturns filename.\n\n\n\n\n\nBase.write(filename::AbstractString, ::Type{GDALarray}, A::AbstractGeoArray;\n           driver=\"GTiff\", compress=\"DEFLATE\", tiled=true)\n\nWrite a GDALarray to file, .tiff by default, but other GDAL drivers also work.\n\nGDAL flags driver, compress and tiled can be passed in as keyword arguments.\n\nReturns filename.\n\n\n\n\n\nBase.write(filename::AbstractString, ::Type{NCDarray}, s::AbstractGeoArray)\n\nWrite an NCDarray to a NetCDF file using NCDatasets.jl\n\nReturns filename.\n\n\n\n\n\nBase.write(filename::AbstractString, ::Type{NCDstack}, s::AbstractGeoStack)\n\nWrite an NCDstack to a single netcdf file, using NCDatasets.jl.\n\nCurrently DimMetadata is not handled, and ArrayMetadata from other AbstractGeoArray @types is ignored.\n\n\n\n\n\n","category":"function"},{"location":"#Base.cat","page":"GeoData.jl","title":"Base.cat","text":"Base.cat(stacks::AbstractGeoStack...; [keys=keys(stacks[1])], dims)\n\nConcatenate all or a subset of layers for all passed in stacks.\n\nKeyword Arguments\n\nkeys: Tuple of Symbol for the stack keys to concatenate.\ndims: Dimension of child array to concatenate on.\n\nExample\n\nConcatenate the :seasurfacetemp and :humidity layers in the time dimension:\n\ncat(stacks...; keys=(:sea_surface_temp, :humidity), dims=Ti)\n\n\n\n\n\n","category":"function"},{"location":"#Base.copy!","page":"GeoData.jl","title":"Base.copy!","text":"Base.copy!(dst::AbstractGeoStack, src::AbstractGeoStack, [keys=keys(dst)])\n\nCopy all or a subset of layers from one stack to another.\n\nExample\n\nCopy just the :sea_surface_temp and :humidity layers from src to dst.\n\ncopy!(dst::AbstractGeoStack, src::AbstractGeoStack, keys=(:sea_surface_temp, :humidity))\n\n\n\n\n\nBase.copy!(dst::AbstractArray, src::DiskGeoStack, key::Key)\n\nCopy the stack layer key to dst, which can be any AbstractArray.\n\nExample\n\nCopy the :humidity layer from stack to array.\n\ncopy!(array, stack, :humidity)\n\n\n\n\n\n","category":"function"},{"location":"#GeoData.replace_missing","page":"GeoData.jl","title":"GeoData.replace_missing","text":"replace_missing(a::AbstractGeoArray, newmissingval)\nreplace_missing(a::AbstractGeoStack, newmissingval)\n\nReplace missing values in the array or stack with a new missing value,  also updating the missingval field/s.\n\n\n\n\n\n","category":"function"},{"location":"#GeoData.boolmask","page":"GeoData.jl","title":"GeoData.boolmask","text":"boolmask(A::AbstractArray, [missingval])\n\nCreate a mask array of Bool values, from any AbstractArray. For AbstractGeoArray  the default missingval is missingval(A), for all other AbstractArrays  it is missing.\n\nThe array returned from calling boolmask on a AbstractGeoArray is a  GeoArray with the same size and fields as the oridingl array\n\n\n\n\n\n","category":"function"},{"location":"#GeoData.missingmask","page":"GeoData.jl","title":"GeoData.missingmask","text":"missingmask(A::AbstractArray, [missingval])\n\nCreate a mask array of missing or true values, from any AbstractArray.  For AbstractGeoArray the default missingval is missingval(A),  for all other AbstractArrays it is missing.\n\nThe array returned from calling boolmask on a AbstractGeoArray is a  GeoArray with the same size and fields as the oridingl array\n\n\n\n\n\n","category":"function"},{"location":"#GeoData.convertmode","page":"GeoData.jl","title":"GeoData.convertmode","text":"convertmode(dstmode::Type{<:IndexMode}, x)\n\nConvert the dimension mode between Projected and Converted. Other dimension modes pass through unchanged.\n\nThis is used to e.g. save a netcdf file to GeoTiff.\n\n\n\n\n\n","category":"function"},{"location":"#GeoData.reproject","page":"GeoData.jl","title":"GeoData.reproject","text":"reproject uses ArchGDAL.reproject, but implemented for a reprojecting  a single dimension at a time.\n\n\n\n\n\n","category":"function"},{"location":"#GeoData.aggregate","page":"GeoData.jl","title":"GeoData.aggregate","text":"aggregate(method, object, scale)\n\nAggregate array, or all arrays in a stack or series, by some scale.\n\nArguments\n\nmethod: a function such as mean or sum that can combine the value of multiple cells to generate the aggregated cell, or a Locus like Start() or Center() that species where to sample from in the interval.\nobject: Object to aggregate, like AbstractGeoSeries, AbstractStack,  AbstractGeoArray, Dimension\nscale: the aggregation factor, which can be an integer, a tuple of integers for each dimension, or any Dimension, Selector or Int combination you can usually use in getindex. Using a Selector will determine the scale by the distance from the start of the index.\n\n\n\n\n\n","category":"function"},{"location":"#GeoData.aggregate!","page":"GeoData.jl","title":"GeoData.aggregate!","text":"aggregate!(method, dst::AbstractDimensionalArray, src::AbstractDimensionalArray, scale)\n\nAggregate array src to array dst by scale, using method.\n\nArguments\n\nmethod: a function such as mean or sum that can combine the value of multiple cells to generate the aggregated cell, or a Locus like Start() or Center() that species where to sample from in the interval.\nscale: the aggregation factor, which can be an integer, a tuple of integers for each dimension, or any Dimension, Selector or Int combination you can usually use in getindex. Using a Selector will determine the scale by the distance from the start of the index in the src array.\n\n\n\n\n\n","category":"function"},{"location":"#GeoData.disaggregate","page":"GeoData.jl","title":"GeoData.disaggregate","text":"disaggregate(method, object, scale)\n\nDisaggregate array, or all arrays in a stack or series, by some scale.\n\nArguments\n\nmethod: a function such as mean or sum that can combine the value of multiple cells to generate the aggregated cell, or a Locus like Start() or Center() that species where to sample from in the interval.\nobject: Object to aggregate, like AbstractGeoSeries, AbstractStack,  AbstractGeoArray, Dimension\nscale: the aggregation factor, which can be an integer, a tuple of integers for each dimension, or any Dimension, Selector or Int combination you can usually use in getindex. Using a Selector will determine the scale by the distance from the start of the index.\n\n\n\n\n\n","category":"function"},{"location":"#GeoData.disaggregate!","page":"GeoData.jl","title":"GeoData.disaggregate!","text":"disaggregate!(method, dst::AbstractDimensionalArray, src::AbstractDimensionalArray, scale)\n\nDisaggregate array src to array dst by some scale, using method.\n\nmethod: a function such as mean or sum that can combine the value of multiple cells to generate the aggregated cell, or a Locus like Start() or Center() that species where to sample from in the interval.\nscale: the aggregation factor, which can be an integer, a tuple of integers for each dimension, or any Dimension, Selector or Int combination you can usually use in getindex. Using a Selector will determine the scale by the distance from the start of the index in the src array.\n\n\n\n\n\n","category":"function"},{"location":"#GeoData.alloc_ag","page":"GeoData.jl","title":"GeoData.alloc_ag","text":"alloc_ag(method, A::AbstractDimensionalArray, scale)\n\nAllocate an array of the correct size to aggregate A by scale\n\n\n\n\n\n","category":"function"},{"location":"#GeoData.alloc_disag","page":"GeoData.jl","title":"GeoData.alloc_disag","text":"alloc_ag(method, A::AbstractDimensionalArray, scale)\n\nAllocate an array of the correct size to disaggregate A by scale\n\n\n\n\n\n","category":"function"},{"location":"","page":"GeoData.jl","title":"GeoData.jl","text":"Field access:","category":"page"},{"location":"","page":"GeoData.jl","title":"GeoData.jl","text":"missingval\ncrs\nusercrs\ndimcrs\nuserbounds\nuserval\nGeoData.filename","category":"page"},{"location":"#GeoData.missingval","page":"GeoData.jl","title":"GeoData.missingval","text":"missingval(x)\n\nReturns the value representing missing data in the dataset\n\n\n\n\n\n","category":"function"},{"location":"#GeoData.crs","page":"GeoData.jl","title":"GeoData.crs","text":"crs(x)\n\nGet the crs projection of a dim or for the Lat/Lon dims of an array.\n\n\n\n\n\n","category":"function"},{"location":"#GeoData.usercrs","page":"GeoData.jl","title":"GeoData.usercrs","text":"usercrs(x)\n\nGet the user facing crs projection of a Projected mode  dim or for the Lat/Lon dims of an array.\n\nThis is used to convert Selector values form the user defined  projection to the underlying projection, and to show plot axes in the user projection.\n\n\n\n\n\n","category":"function"},{"location":"#GeoData.dimcrs","page":"GeoData.jl","title":"GeoData.dimcrs","text":"dimcrs(x)\n\nGet the index crs projection of a Converted mode dim or  for the Lat/Lon dims of an array.\n\nThis is used for NetCDF and other formats where the underlying projection  of the data may  be different to what is contained in the vector index.\n\n\n\n\n\n","category":"function"},{"location":"#GeoData.userbounds","page":"GeoData.jl","title":"GeoData.userbounds","text":"userbounds(x)\n\nGet the bounds converted to the usercrs value.\n\nWhithout ArchGDAL loaded, this is just the regular bounds.\n\n\n\n\n\n","category":"function"},{"location":"#GeoData.userval","page":"GeoData.jl","title":"GeoData.userval","text":"userval(x)\n\nGet the index value of a dimension converted to the usercrs value.\n\nWhithout ArchGDAL loaded, this is just the regular dim value.\n\n\n\n\n\n","category":"function"},{"location":"#GeoData.filename","page":"GeoData.jl","title":"GeoData.filename","text":"filename(s::DiskGeoStack)\n\nReturn the filename field of a DiskGeoStack.  This may be a Vector of String, or a String.\n\n\n\n\n\nfilename(s::DiskGeoStack, key)\n\nReturn the filename field of a DiskGeoStack for a given key.\n\nThis will always be a single string. However, in some cases all keys may have the same filename.\n\n\n\n\n\n","category":"function"}]
}
